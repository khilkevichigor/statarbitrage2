package com.example.core.schedulers;

import com.example.core.processors.UpdateTradeProcessor;
import com.example.core.services.EventSendService;
import com.example.core.services.TradingPairService;
import com.example.shared.dto.UpdateTradeRequest;
import com.example.shared.enums.TradeStatus;
import com.example.shared.events.UpdateUiEvent;
import com.example.shared.models.TradingPair;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

@Slf4j
@Component
@RequiredArgsConstructor
public class TradeAndSimulationScheduler {

    // –§–ª–∞–≥–∏ –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ —à–µ–¥—É–ª–ª–µ—Ä–æ–≤
    private final AtomicBoolean updateTradesRunning = new AtomicBoolean(false);
    private final AtomicBoolean maintainPairsRunning = new AtomicBoolean(false);

    //    private final SettingsService settingsService;
    private final TradingPairService tradingPairService;
    private final UpdateTradeProcessor updateTradeProcessor;
    //    private final StartNewTradeProcessor startNewTradeProcessor;
//    private final FetchPairsProcessor fetchPairsProcessor;
    private final EventSendService eventSendService;
//    private final TradingIntegrationService tradingIntegrationServiceImpl;

    //    @Scheduled(cron = "0 * * * * *") // –ö–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É –≤ 0 —Å–µ–∫—É–Ω–¥
    @Scheduled(initialDelay = 15000, fixedRate = 60000) // –ö–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É –≤ 0 —Å–µ–∫—É–Ω–¥
    public void updateTrades() {
        if (!canStartUpdateTrades()) {
            return;
        }

        long schedulerStart = System.currentTimeMillis();

        try {
            List<TradingPair> tradingPairs = executeUpdateTrades();
            logUpdateTradesCompletion(schedulerStart, tradingPairs.size());
        } finally {
            updateTradesRunning.set(false);
        }
    }

    //todo —Å—á–∏—Ç–∞—Ç—å –ø–æ –±–∞–ª–∞–Ω—Å—É —Å–∫–æ–ª—å–∫–æ –º–æ–∂–Ω–æ –ø–∞—Ä –≤–µ—Å—Ç–∏! –Ω–∞–ø—Ä–∏–º–µ—Ä –±–∞–ª–∞–Ω—Å 10–∫ –∏ –¥–µ–ª–∞–µ–º 10 –ø–∞—Ä –ø–æ 1–∫ (–ø–æ 500$)! –¢–æ–≥–¥–∞ –æ—Å—Ç–∞–≤–ª—è–µ–º 10% –Ω–∞ –∑–∞–ø–∞—Å –Ω–∞ –ø—Ä–æ—Å–∞–¥–∫—É! –ò—Ç–æ–≥–æ –æ—Ç–∫—Ä–æ–µ–º 9 –ø–∞—Ä –Ω–∞ 9–∫!
    // –ò —Ç–∞–∫ —Å—á–∏—Ç–∞—Ç—å –∫–∞–∂–¥—ã–π —Ä–∞–∑! –ü—Ä–∏ —Ä–æ—Å—Ç–µ –±–∞–ª–∞–Ω—Å–∞ –±—É–¥–µ–º –æ—Ç–∫—Ä—ã–≤–∞—Ç—å –±–æ–ª—å—à–µ –ø–∞—Ä –∏ –Ω–∞–æ–±–æ—Ä–æ—Ç! –ü–æ–ª–Ω—ã–π –∞–≤—Ç–æ—Ç—Ä–µ–π–¥–∏–Ω–≥!=)
//    @Scheduled(cron = "0 */5 * * * *") // –ö–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç –≤ 0 —Å–µ–∫—É–Ω–¥
//    public void maintainPairs() {
//        if (!canStartMaintainPairs()) {
//            return;
//        }
//
//        long schedulerStart = System.currentTimeMillis();
//
//        try {
//            int newPairsCount = executeMaintainPairs();
//            logMaintainPairsCompletion(schedulerStart, newPairsCount);
//        } finally {
//            maintainPairsRunning.set(false);
//        }
//    }

    private boolean canStartUpdateTrades() {
        if (maintainPairsRunning.get()) {
            log.debug("‚è∏Ô∏è –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç—Ä–µ–π–¥–æ–≤ –ø—Ä–æ–ø—É—â–µ–Ω–æ - –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏–µ –ø–∞—Ä");
            return false;
        }

        if (!updateTradesRunning.compareAndSet(false, true)) {
            log.warn("‚ö†Ô∏è –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç—Ä–µ–π–¥–æ–≤ —É–∂–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è");
            return false;
        }

        return true;
    }

    private List<TradingPair> executeUpdateTrades() {
        log.debug("üîÑ –®–µ–¥—É–ª–ª–µ—Ä –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ç—Ä–µ–π–¥–æ–≤ –∑–∞–ø—É—â–µ–Ω...");

        List<TradingPair> updatablePairs = getUpdatablePairs();
        if (updatablePairs.isEmpty()) {
            return updatablePairs;
        }

//        updatePositionsPrices();
        processTradeUpdates(updatablePairs);
        updateUI();

        return updatablePairs;
    }

    private List<TradingPair> getUpdatablePairs() {
        try {
            return tradingPairService.findAllByStatusIn(List.of(TradeStatus.TRADING, TradeStatus.OBSERVED));
        } catch (Exception e) {
            log.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä: {}", e.getMessage());
            return List.of();
        }
    }

    private void processTradeUpdates(List<TradingPair> updatablePairs) {
        updatablePairs.forEach(this::updateSingleTrade);
    }

    private void updateSingleTrade(TradingPair tradingPair) {
        try {
            if (tradingPair.getStatus() == TradeStatus.TRADING) {
                updateTradeProcessor.updateTrade(UpdateTradeRequest.builder()
                        .tradingPair(tradingPair)
                        .closeManually(false)
                        .build());
            } else if (tradingPair.getStatus() == TradeStatus.OBSERVED) {
                // Here we will call a new method to only update cointegration data
                updateTradeProcessor.updateObservedPair(tradingPair);
            }
        } catch (Exception e) {
            log.warn("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–∞—Ä—ã {}: {}", tradingPair.getPairName(), e.getMessage());
        }
    }

    private void updateUI() {
        try {
            eventSendService.updateUI(UpdateUiEvent.builder().build());
        } catch (Exception e) {
            log.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ UI: {}", e.getMessage());
        }
    }

    private void logUpdateTradesCompletion(long startTime, int tradesCount) {
        long duration = System.currentTimeMillis() - startTime;
        log.debug("‚è±Ô∏è –®–µ–¥—É–ª–ª–µ—Ä –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ç—Ä–µ–π–¥–æ–≤ –∑–∞–∫–æ–Ω—á–∏–ª —Ä–∞–±–æ—Ç—É –∑–∞ {} —Å–µ–∫. –û–±–Ω–æ–≤–ª–µ–Ω–æ {} —Ç—Ä–µ–π–¥–æ–≤",
                duration / 1000.0, tradesCount);
    }

//    private boolean canStartMaintainPairs() {
//        if (!waitForUpdateTradesCompletion()) {
//            return false;
//        }
//
//        if (!maintainPairsRunning.compareAndSet(false, true)) {
//            log.warn("‚ö†Ô∏è –ü–æ–¥–¥–µ—Ä–∂–∞–Ω–∏–µ –ø–∞—Ä —É–∂–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è");
//            return false;
//        }
//
//        return true;
//    }

//    private boolean waitForUpdateTradesCompletion() {
//        if (!updateTradesRunning.get()) {
//            return true;
//        }
//
//        log.debug("‚è≥ –ü–æ–¥–¥–µ—Ä–∂–∞–Ω–∏–µ –ø–∞—Ä –∂–¥–µ—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ç—Ä–µ–π–¥–æ–≤...");
//
//        int waitTime = 0;
//        final int maxWaitTime = 60_000; // 60 —Å–µ–∫—É–Ω–¥
//        final int sleepInterval = 1000; // 1 —Å–µ–∫—É–Ω–¥–∞
//
//        while (updateTradesRunning.get() && waitTime < maxWaitTime) {
//            try {
//                Thread.sleep(sleepInterval);
//                waitTime += sleepInterval;
//            } catch (InterruptedException e) {
//                Thread.currentThread().interrupt();
//                log.warn("‚ö†Ô∏è –ü—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ –æ–∂–∏–¥–∞–Ω–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ç—Ä–µ–π–¥–æ–≤");
//                return false;
//            }
//        }
//
//        if (updateTradesRunning.get()) {
//            log.warn("‚ö†Ô∏è –ü–æ–¥–¥–µ—Ä–∂–∞–Ω–∏–µ –ø–∞—Ä –æ—Ç–º–µ–Ω–µ–Ω–æ - –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç—Ä–µ–π–¥–æ–≤ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è —Å–ª–∏—à–∫–æ–º –¥–æ–ª–≥–æ");
//            return false;
//        }
//
//        return true;
//    }

//    private int executeMaintainPairs() {
//        log.debug("üîÑ –®–µ–¥—É–ª–ª–µ—Ä –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏—è –∫–æ–ª-–≤–∞ —Ç—Ä–µ–π–¥–æ–≤ –∑–∞–ø—É—â–µ–Ω...");
//
//        Settings settings = loadSettings();
//        if (settings == null || !settings.isAutoTradingEnabled()) {
//            return 0;
//        }
//
//        int missingPairs = calculateMissingPairs(settings);
//        if (missingPairs <= 0) {
//            return 0;
//        }
//
//        return createAndStartNewPairs(missingPairs); //todo –º–æ–∂–µ—Ç —Ç–∞—â–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å—Ä–∞–∑—É –æ—Ç—Å—é–¥–∞???
//    }

//    private Settings loadSettings() {
//        try {
//            return settingsService.getSettings();
//        } catch (Exception e) {
//            log.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –Ω–∞—Å—Ç—Ä–æ–µ–∫: {}", e.getMessage());
//            return null;
//        }
//    }

//    private int calculateMissingPairs(Settings settings) {
//        try {
//            List<TradingPair> tradingPairs = tradingPairService.findAllByStatusOrderByEntryTimeDesc(TradeStatus.TRADING);
//            int maxActive = (int) settings.getUsePairs();
//            int currentActive = tradingPairs.size();
//            return maxActive - currentActive;
//        } catch (Exception e) {
//            log.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏—Ö –ø–∞—Ä: {}", e.getMessage());
//            return 0;
//        }
//    }

//    private int createAndStartNewPairs(int missingPairs) {
//        log.debug("üÜï –ù–µ —Ö–≤–∞—Ç–∞–µ—Ç {} –ø–∞—Ä ‚Äî –Ω–∞—á–∏–Ω–∞–µ–º –ø–æ–¥–±–æ—Ä", missingPairs);
//
//        cleanupOldSelectedPairs();
//
//        List<TradingPair> newPairs = fetchNewPairs(missingPairs);
//        if (newPairs.isEmpty()) {
//            log.warn("‚ö†Ô∏è –û—Ç–æ–±—Ä–∞–Ω–æ 0 –ø–∞—Ä!");
//            return 0;
//        }
//
//        log.info("–û—Ç–æ–±—Ä–∞–Ω–æ {} –ø–∞—Ä", newPairs.size());
//
//        int startedCount = startNewTrades(newPairs);
//
//        if (startedCount > 0) {
//            updateUI();
//        }
//
//        return startedCount;
//    }

//    private void cleanupOldSelectedPairs() {
//        try {
//            tradingPairService.deleteAllByStatus(TradeStatus.SELECTED);
//        } catch (Exception e) {
//            log.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ —Å—Ç–∞—Ä—ã—Ö –ø–∞—Ä SELECTED: {}", e.getMessage());
//        }
//    }
//
//    private List<TradingPair> fetchNewPairs(int count) {
//        try {
//            return fetchPairsProcessor.fetchPairs(FetchPairsRequest.builder()
//                    .countOfPairs(count)
//                    .build());
//        } catch (Exception e) {
//            log.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ –Ω–æ–≤—ã—Ö –ø–∞—Ä: {}", e.getMessage());
//            return List.of();
//        }
//    }

//    private int startNewTrades(List<TradingPair> newPairs) {
//        AtomicInteger count = new AtomicInteger(0);
//
//        newPairs.forEach(pairData -> {
//            if (startSingleNewTrade(pairData)) {
//                count.incrementAndGet();
//            }
//        });
//
//        return count.get();
//    }

//    private boolean startSingleNewTrade(TradingPair tradingPair) {
//        try {
//            TradingPair result = startNewTradeProcessor.startNewTrade(StartNewTradeRequest.builder()
//                    .tradingPair(tradingPair)
//                    .checkAutoTrading(true)
//                    .build());
//            return result != null;
//        } catch (Exception e) {
//            log.warn("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å –Ω–æ–≤—ã–π —Ç—Ä–µ–π–¥ –¥–ª—è –ø–∞—Ä—ã {}: {}", tradingPair.getPairName(), e.getMessage());
//            return false;
//        }
//    }

//    private void logMaintainPairsCompletion(long startTime, int newPairsCount) {
//        long duration = System.currentTimeMillis() - startTime;
//        log.debug("‚è±Ô∏è –®–µ–¥—É–ª–ª–µ—Ä –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏—è –∫–æ–ª-–≤–∞ —Ç—Ä–µ–π–¥–æ–≤ –∑–∞–∫–æ–Ω—á–∏–ª —Ä–∞–±–æ—Ç—É –∑–∞ {} —Å–µ–∫. –ó–∞–ø—É—â–µ–Ω–æ {} –Ω–æ–≤—ã—Ö –ø–∞—Ä", duration / 1000.0, newPairsCount);
//    }
}
