package com.example.statarbitrage.bot;

import com.example.statarbitrage.events.SendAsTextEvent;
import com.example.statarbitrage.model.UserSettings;
import com.example.statarbitrage.processors.ScreenerProcessor;
import com.example.statarbitrage.services.SettingsService;
import com.example.statarbitrage.utils.StringUtil;
import com.fasterxml.jackson.core.JsonProcessingException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Service;
import org.telegram.telegrambots.bots.TelegramLongPollingBot;
import org.telegram.telegrambots.meta.api.methods.commands.SetMyCommands;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.api.methods.updatingmessages.EditMessageText;
import org.telegram.telegrambots.meta.api.objects.Message;
import org.telegram.telegrambots.meta.api.objects.Update;
import org.telegram.telegrambots.meta.api.objects.commands.BotCommand;
import org.telegram.telegrambots.meta.api.objects.commands.scope.BotCommandScopeDefault;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

@Slf4j
@Service
public class TelegramBot extends TelegramLongPollingBot {
    @Autowired
    private ScreenerProcessor screenerProcessor;
    @Autowired
    private SettingsService settingsService;
    private final BotConfig botConfig;

    private final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    private final AtomicBoolean isAutoScanRunning = new AtomicBoolean(false);
    private ScheduledFuture<?> autoScanTask;
    private Integer lastSentMessageId;
    private String lastSentText = ""; // –Ω–æ–≤–æ–µ –ø–æ–ª–µ

    public TelegramBot(BotConfig botConfig) {
        this.botConfig = botConfig;
        List<BotCommand> listOfCommands = new ArrayList<>();
        listOfCommands.add(new BotCommand(BotMenu.SCAN_ALL.getName(), "–°–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å"));
        listOfCommands.add(new BotCommand(BotMenu.SCAN_BTC.getName(), "–°–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å BTC"));
        listOfCommands.add(new BotCommand(BotMenu.START_AUTOSCAN.getName(), "–°—Ç–∞—Ä—Ç –∞–≤—Ç–æ—Å–∫–∞–Ω"));
        listOfCommands.add(new BotCommand(BotMenu.STOP_AUTOSCAN.getName(), "–°—Ç–æ–ø –∞–≤—Ç–æ—Å–∫–∞–Ω"));
        listOfCommands.add(new BotCommand(BotMenu.GET_SETTINGS.getName(), "–ü–æ–ª—É—á–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"));
        listOfCommands.add(new BotCommand(BotMenu.RESET_SETTINGS.getName(), "–°–±—Ä–æ—Å–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"));
        try {
            this.execute(new SetMyCommands(listOfCommands, new BotCommandScopeDefault(), null));
        } catch (TelegramApiException e) {
            log.error("Error setting bot's command list: " + e.getMessage());
        }
    }

    @Override
    public String getBotUsername() {
        return botConfig.getBotName();
    }

    @Override
    public String getBotToken() {
        return botConfig.getToken();
    }

    @Override
    public void onUpdateReceived(Update update) {
        if (update.hasMessage()) {
            String chatIdStr = String.valueOf(update.getMessage().getChatId());
            long chatId = update.getMessage().getChatId();
            Message message = update.getMessage();
            String text = message.getText();

            if (Objects.equals(text, BotMenu.SCAN_BTC.getName())) {
                log.info("-> SCAN_BTC");
                screenerProcessor.process(chatIdStr, "BTC-USDT-SWAP");
            } else if (Objects.equals(text, BotMenu.SCAN_ALL.getName())) {
                log.info("-> SCAN_ALL");
                screenerProcessor.process(chatIdStr, null);
            } else if (text.equals("/get_settings")) {
                log.info("-> GET_SETTINGS");
                UserSettings settings = settingsService.getSettings(chatId);
                String json;
                try {
                    json = new com.fasterxml.jackson.databind.ObjectMapper().writerWithDefaultPrettyPrinter().writeValueAsString(settings);
                } catch (JsonProcessingException e) {
                    throw new RuntimeException(e);
                }
                sendMessage(chatIdStr, "```json\n" + json + "\n```");

            } else if (text.startsWith("/set_settings") || text.startsWith("/ss")) {
                log.info("-> SET_SETTINGS");
                try {
                    String jsonPart = text.replace(text.startsWith("/set_settings") ? "/set_settings" : "/ss", "").trim();
                    UserSettings newSettings = new com.fasterxml.jackson.databind.ObjectMapper().readValue(jsonPart, UserSettings.class);
                    settingsService.updateAllSettings(chatId, newSettings);
                    sendMessage(chatIdStr, "‚úÖ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω—ã!");
                } catch (Exception e) {
                    log.warn("‚ùå –û—à–∏–±–∫–∞ —Ä–∞–∑–±–æ—Ä–∞ JSON: {}", e.getMessage());
                    sendMessage(chatIdStr, "‚ùå –û—à–∏–±–∫–∞ —Ä–∞–∑–±–æ—Ä–∞ JSON: " + e.getMessage());
                }
            } else if (text.equals("/reset_settings")) {
                log.info("-> RESET_SETTINGS");
                settingsService.resetSettings(chatId);
                sendMessage(chatIdStr, "üîÑ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–±—Ä–æ—à–µ–Ω—ã –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.");
            } else if (text.startsWith("/check")) {
                log.info("-> CHECK COIN");
                try {
                    String symbolPart = text.replace("/check", "").trim();
                    screenerProcessor.process(chatIdStr, StringUtil.getSymbol(symbolPart));
                } catch (Exception e) {
                    log.warn("‚ùå –û—à–∏–±–∫–∞ —Ä–∞–∑–±–æ—Ä–∞ –∫–æ–º–∞–Ω–¥—ã: {}", e.getMessage());
                    sendMessage(chatIdStr, "‚ùå –û—à–∏–±–∫–∞ —Ä–∞–∑–±–æ—Ä–∞ –∫–æ–º–∞–Ω–¥—ã: " + e.getMessage());
                }
            } else if (Objects.equals(text, BotMenu.START_AUTOSCAN.getName())) {
                log.info("-> START_AUTOSCAN");
                startAutoScan(chatIdStr);
            } else if (Objects.equals(text, BotMenu.STOP_AUTOSCAN.getName())) {
                log.info("-> STOP_AUTOSCAN");
                stopAutoScan(chatIdStr);
            }
        }
    }

    private void startAutoScan(String chatId) {
        if (isAutoScanRunning.get()) {
            sendMessage(chatId, "‚è≥ –ê–≤—Ç–æ-—Å–∫–∞–Ω —É–∂–µ –∑–∞–ø—É—â–µ–Ω");
            return;
        }

        isAutoScanRunning.set(true);
        sendMessage(chatId, "üîç –ê–≤—Ç–æ—Å–∫–∞–Ω –∑–∞–ø—É—â–µ–Ω...");

        UserSettings userSettings = settingsService.getSettings(Long.parseLong(chatId));
        boolean sendNewEachTime = userSettings.isSendNewMessageOnAutoScan(); // –Ω–æ–≤—ã–π —Ñ–ª–∞–≥

        if (!sendNewEachTime) {
            // –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–µ—Ä–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –±—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª—è—Ç—å—Å—è
            SendMessage initial = new SendMessage();
            initial.setChatId(chatId);
            initial.setText("–ñ–¥–µ–º –º–æ–Ω–µ—Ç—ã...");
            try {
                Message sent = execute(initial);
                lastSentMessageId = sent.getMessageId();
            } catch (TelegramApiException e) {
                log.error("–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å—Ç–∞—Ä—Ç–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è", e);
                return;
            }
        }

        autoScanTask = scheduler.scheduleAtFixedRate(() -> {
            try {
                String result = screenerProcessor.scanAllAuto(chatId);
                String newText = result.isEmpty() ? "ü§∑–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ" : result;

                if (!newText.equals(lastSentText)) {
                    if (sendNewEachTime) {
                        SendMessage newMessage = new SendMessage();
                        newMessage.setChatId(chatId);
                        newMessage.setText(newText);
                        execute(newMessage);
                    } else {
                        EditMessageText edit = new EditMessageText();
                        edit.setChatId(chatId);
                        edit.setMessageId(lastSentMessageId);
                        edit.setText(newText);
                        execute(edit);
                    }

                    lastSentText = newText;
                    log.info("–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞–≤—Ç–æ-—Å–∫–∞–Ω–∞: {}", newText);
                }

            } catch (Exception e) {
                log.error("–û—à–∏–±–∫–∞ –≤ autoScan", e);
            }
        }, 0, userSettings.getAutoScan().getIntervalSec().intValue(), TimeUnit.SECONDS);
    }


    private void stopAutoScan(String chatId) {
        if (!isAutoScanRunning.get()) {
            sendMessage(chatId, "‚õî –ê–≤—Ç–æ-—Å–∫–∞–Ω –Ω–µ –∑–∞–ø—É—â–µ–Ω");
            return;
        }

        isAutoScanRunning.set(false);
        if (autoScanTask != null) {
            autoScanTask.cancel(true);
        }

        sendMessage(chatId, "‚úÖ –ê–≤—Ç–æ-—Å–∫–∞–Ω –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω");
    }

    @EventListener
    public void onSendAsTextEvent(SendAsTextEvent event) {
        SendMessage message = new SendMessage();
        message.setChatId(event.getChatId());
        message.setText(event.getText());
        message.enableMarkdown(event.isEnableMarkdown());
        sendMessage(message);
    }

    private void sendMessage(String chatId, String text) {
        SendMessage message = new SendMessage();
        message.setChatId(chatId);
        message.setText(text);
        message.enableMarkdown(true);
        sendMessage(message);
    }

    private void sendMessage(SendMessage message) {
        try {
            execute(message);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }

}
