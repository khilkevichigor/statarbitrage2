package com.example.statarbitrage.bot;

import com.example.statarbitrage.events.ResetProfitEvent;
import com.example.statarbitrage.events.SendAsPhotoEvent;
import com.example.statarbitrage.events.SendAsTextEvent;
import com.example.statarbitrage.model.Settings;
import com.example.statarbitrage.processors.ScreenerProcessor;
import com.example.statarbitrage.services.EventSendService;
import com.example.statarbitrage.services.FileService;
import com.example.statarbitrage.services.SettingsService;
import com.fasterxml.jackson.core.JsonProcessingException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Service;
import org.telegram.telegrambots.bots.TelegramLongPollingBot;
import org.telegram.telegrambots.meta.api.methods.commands.SetMyCommands;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.api.methods.send.SendPhoto;
import org.telegram.telegrambots.meta.api.objects.InputFile;
import org.telegram.telegrambots.meta.api.objects.Message;
import org.telegram.telegrambots.meta.api.objects.Update;
import org.telegram.telegrambots.meta.api.objects.commands.BotCommand;
import org.telegram.telegrambots.meta.api.objects.commands.scope.BotCommandScopeDefault;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

@Slf4j
@Service
public class TelegramBot extends TelegramLongPollingBot {
    @Autowired
    private ScreenerProcessor screenerProcessor;
    @Autowired
    private SettingsService settingsService;
    @Autowired
    private FileService fileService;
    @Autowired
    private EventSendService eventSendService;
    private final BotConfig botConfig;

    private final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    private final AtomicBoolean isStartTestTradeRunning = new AtomicBoolean(false);
    private ScheduledFuture<?> testTradeTask;

    public TelegramBot(BotConfig botConfig) {
        this.botConfig = botConfig;
        List<BotCommand> listOfCommands = new ArrayList<>();
        listOfCommands.add(new BotCommand(BotMenu.FIND.getName(), "–ò—Å–∫–∞—Ç—å"));
//        listOfCommands.add(new BotCommand(BotMenu.START_TEST_TRADE.getName(), "–°—Ç–∞—Ä—Ç —Ç–µ—Å—Ç-—Ç—Ä–µ–π–¥"));
        listOfCommands.add(new BotCommand(BotMenu.START_TEST_TRADE_L_A_S_B.getName(), "–°—Ç–∞—Ä—Ç —Ç–µ—Å—Ç-—Ç—Ä–µ–π–¥ long a, short b"));
        listOfCommands.add(new BotCommand(BotMenu.START_TEST_TRADE_L_B_S_A.getName(), "–°—Ç–∞—Ä—Ç —Ç–µ—Å—Ç-—Ç—Ä–µ–π–¥ long b, short a"));
        listOfCommands.add(new BotCommand(BotMenu.STOP_TEST_TRADE.getName(), "–°—Ç–æ–ø —Ç–µ—Å—Ç-—Ç—Ä–µ–π–¥"));
        listOfCommands.add(new BotCommand(BotMenu.GET_SETTINGS.getName(), "–ü–æ–ª—É—á–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"));
        listOfCommands.add(new BotCommand(BotMenu.RESET_SETTINGS.getName(), "–°–±—Ä–æ—Å–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"));
        listOfCommands.add(new BotCommand(BotMenu.DELETE_FILES.getName(), "–£–¥–∞–ª–∏—Ç—å —Ñ–∞–π–ª—ã"));
        try {
            this.execute(new SetMyCommands(listOfCommands, new BotCommandScopeDefault(), null));
        } catch (TelegramApiException e) {
            log.error("Error setting bot's command list: " + e.getMessage());
        }
    }

    @Override
    public String getBotUsername() {
        return botConfig.getBotName();
    }

    @Override
    public String getBotToken() {
        return botConfig.getToken();
    }

    @Override
    public void onUpdateReceived(Update update) {
        if (update.hasMessage()) {
            String chatIdStr = String.valueOf(update.getMessage().getChatId());
            long chatId = update.getMessage().getChatId();
            Message message = update.getMessage();
            String text = message.getText();

            if (Objects.equals(text, BotMenu.FIND.getName())) {
                log.info("-> FIND");
                stopTestTrade(chatIdStr);
                sendMessage(chatIdStr, "üîç –ü–æ–∏—Å–∫ –ª—É—á—à–µ–π –ø–∞—Ä—ã –∑–∞–ø—É—â–µ–Ω...");
                //todo —Å–Ω–∞—á–∞–ª–∞ —Å–ª–∞—Ç—å –ª—É—á—à–∏–π —á–∞—Ä—Ç –ø–æ –æ–≥—Ä–æ–º–Ω–æ–º—É —Ç—Ñ 1—á –∏–ª–∏ 1–¥ –¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è
                screenerProcessor.sendBestChart(chatIdStr);
            } else if (Objects.equals(text, BotMenu.GET_SETTINGS.getName())) {
                log.info("-> GET_SETTINGS");
                Settings settings = settingsService.getSettings();
                String json;
                try {
                    json = new com.fasterxml.jackson.databind.ObjectMapper().writerWithDefaultPrettyPrinter().writeValueAsString(settings);
                } catch (JsonProcessingException e) {
                    throw new RuntimeException(e);
                }
                sendMessage(chatIdStr, "```json\n" + json + "\n```");

            } else if (text.startsWith("/set_settings") || text.startsWith("/ss")) {
                log.info("-> SET_SETTINGS");
                try {
                    String jsonPart = text.replace(text.startsWith("/set_settings") ? "/set_settings" : "/ss", "").trim();
                    Settings newSettings = new com.fasterxml.jackson.databind.ObjectMapper().readValue(jsonPart, Settings.class);
                    settingsService.updateAllSettings(chatId, newSettings);
                    sendMessage(chatIdStr, "‚úÖ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω—ã!");
                } catch (Exception e) {
                    log.warn("‚ùå –û—à–∏–±–∫–∞ —Ä–∞–∑–±–æ—Ä–∞ JSON: {}", e.getMessage());
                    sendMessage(chatIdStr, "‚ùå –û—à–∏–±–∫–∞ —Ä–∞–∑–±–æ—Ä–∞ JSON: " + e.getMessage());
                }
            } else if (Objects.equals(text, BotMenu.RESET_SETTINGS.getName())) {
                log.info("-> RESET_SETTINGS");
                settingsService.resetSettings(chatId);
                sendMessage(chatIdStr, "üîÑ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–±—Ä–æ—à–µ–Ω—ã –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.");
            }
//            else if (Objects.equals(text, BotMenu.START_TEST_TRADE.getName())) {
//                log.info("-> START_TEST_TRADE");
//                startTestTrade(chatIdStr);
//            }
            else if (Objects.equals(text, BotMenu.START_TEST_TRADE_L_A_S_B.getName())) {
                log.info("-> START_TEST_TRADE_L_A_S_B");
                startTestTrade(chatIdStr, true);
            } else if (Objects.equals(text, BotMenu.START_TEST_TRADE_L_B_S_A.getName())) {
                log.info("-> START_TEST_TRADE_L_B_S_A");
                startTestTrade(chatIdStr, false);
            } else if (Objects.equals(text, BotMenu.STOP_TEST_TRADE.getName())) {
                log.info("-> STOP_TEST_TRADE");
                stopTestTrade(chatIdStr);
            } else if (Objects.equals(text, BotMenu.DELETE_FILES.getName())) {
                log.info("-> DELETE_FILES");
                fileService.deleteSpecificFilesInProjectRoot(List.of("z_score.json", "pair_data.json", "candles.json"));
            }
        }
    }

    private void startTestTrade(String chatId, boolean isLasb) {
        if (isStartTestTradeRunning.get()) {
            sendMessage(chatId, "‚è≥ –¢–µ—Å—Ç-—Ç—Ä–µ–π–¥ —É–∂–µ –∑–∞–ø—É—â–µ–Ω");
            return;
        }

        isStartTestTradeRunning.set(true);
        sendMessage(chatId, "üîç –¢–µ—Å—Ç-—Ç—Ä–µ–π–¥ –∑–∞–ø—É—â–µ–Ω...");

        testTradeTask = scheduler.scheduleAtFixedRate(() -> {
            try {
                screenerProcessor.testTrade(chatId, isLasb);
            } catch (Exception e) {
                log.error("–û—à–∏–±–∫–∞ –≤ testTrade()", e);
            }
        }, 0, 60L * settingsService.getSettings().getCheckInterval(), TimeUnit.SECONDS);
    }

    private void stopTestTrade(String chatId) {
        if (!isStartTestTradeRunning.get()) {
            sendMessage(chatId, "‚õî –¢–µ—Å—Ç-—Ç—Ä–µ–π–¥ –Ω–µ –∑–∞–ø—É—â–µ–Ω");
            return;
        }

        isStartTestTradeRunning.set(false);
        if (testTradeTask != null) {
            testTradeTask.cancel(true);
        }

        resetProfit(true);
        sendMessage(chatId, "‚úÖ –¢–µ—Å—Ç-—Ç—Ä–µ–π–¥ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω");
    }

    public void resetProfit(boolean withLogging) {
        try {
            eventSendService.sendResetProfitEvent(ResetProfitEvent.builder().build());
            if (withLogging) {
                log.info("–°–±—Ä–æ—Å–∏–ª–∏ –ø—Ä–æ—Ñ–∏—Ç");
            }
        } catch (Exception e) {
            log.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–±—Ä–æ—Å–µ –ø—Ä–æ—Ñ–∏—Ç–∞: {}", e.getMessage(), e);
        }
    }

    @EventListener
    public void onSendAsTextEvent(SendAsTextEvent event) {
        SendMessage message = new SendMessage();
        message.setChatId(event.getChatId());
        message.setText(event.getText());
        message.enableMarkdown(event.isEnableMarkdown());
        sendMessage(message);
    }

    @EventListener
    public void onSendAsPhotoEvent(SendAsPhotoEvent event) {
        SendPhoto photo = new SendPhoto();
        photo.setChatId(event.getChatId());
        photo.setPhoto(new InputFile(event.getPhoto()));
        photo.setCaption(event.getCaption());
        photo.setParseMode(event.isEnableMarkdown() ? "Markdown" : null);

        sendPhoto(photo); // ‚úÖ –º–µ—Ç–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Ñ–æ—Ç–æ
    }

    private void sendMessage(String chatId, String text) {
        SendMessage message = new SendMessage();
        message.setChatId(chatId);
        message.setText(text);
        message.enableMarkdown(true);
        sendMessage(message);
    }

    private void sendPhoto(SendPhoto photo) {
        try {
            execute(photo);
        } catch (TelegramApiException e) {
            log.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–æ—Ç–æ: {}", e.getMessage(), e);
        }
    }

    private void sendMessage(SendMessage message) {
        try {
            execute(message);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }

}
