package com.example.statarbitrage.processors;

import com.example.statarbitrage.api.OkxClient;
import com.example.statarbitrage.events.SendAsPhotoEvent;
import com.example.statarbitrage.events.SendAsTextEvent;
import com.example.statarbitrage.model.*;
import com.example.statarbitrage.python.PythonScripts;
import com.example.statarbitrage.python.PythonScriptsExecuter;
import com.example.statarbitrage.services.EventSendService;
import com.example.statarbitrage.services.FileService;
import com.example.statarbitrage.services.ProfitService;
import com.example.statarbitrage.services.SettingsService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;

import java.io.File;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;

@Slf4j
@Component
@RequiredArgsConstructor
public class ScreenerProcessor {

    private final OkxClient okxClient;
    private final EventSendService eventSendService;
    private final SettingsService settingsService;
    private final ProfitService profitService;
    private final FileService fileService;

    private final Map<String, AtomicBoolean> runningTrades = new ConcurrentHashMap<>();

    @Async
    public void testTrade(String chatId) {
        AtomicBoolean isRunning = runningTrades.computeIfAbsent(chatId, k -> new AtomicBoolean(false));
        if (!isRunning.compareAndSet(false, true)) {
            log.warn("testTrade —É–∂–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –¥–ª—è chatId = {}", chatId);
            return;
        }

        try {
            ZScoreEntry topPair = fileService.getTopPairEntry();
            EntryData entryData = fileService.getEntryData();
            Settings settings = settingsService.getSettings(Long.parseLong(chatId));

            ConcurrentHashMap<String, List<Candle>> topPairCandles = saveCandlesToJson(topPair, settings);
            updateCurrentPricesFromCandles(entryData, topPairCandles);
            setupEntryPointsIfNeededFromCandles(entryData, topPair, topPairCandles);
            ProfitData profitData = profitService.calculateAndSetProfit(entryData, settings.getCapitalLong(), settings.getCapitalShort(), settings.getLeverage(), settings.getFeePctPerTrade());

            PythonScriptsExecuter.execute(PythonScripts.Z_SCORE_CANDLES.getName(), true);
            fileService.clearChartDir();
            PythonScriptsExecuter.execute(PythonScripts.CREATE_CHARTS_CANDLES.getName(), true);

            sendChart(chatId, fileService.getChart(), profitData.getLogMessage(), false);
        } catch (Exception e) {
            log.error("‚ùå –û—à–∏–±–∫–∞ –≤ testTrade: {}", e.getMessage(), e);
        } finally {
            isRunning.set(false);
        }
    }

    @Async
    public void sendBestChart(String chatId) {
        long startTime = System.currentTimeMillis();

        fileService.deleteSpecificFilesInProjectRoot(List.of("z_score.json", "entry_data.json", "all_candles.json"));
        log.info("–£–¥–∞–ª–∏–ª–∏ z_score.json, entry_data.json, all_candles.json");

        Settings settings = settingsService.getSettings(Long.parseLong(chatId));

        Set<String> swapTickers = okxClient.getSwapTickers();
        int totalSymbols = swapTickers.size();

        ConcurrentHashMap<String, List<Candle>> allCandles = getCandlesMap(swapTickers, settings);
        log.info("–°–æ–±—Ä–∞–ª–∏ —Ü–µ–Ω—ã –¥–ª—è {} –º–æ–Ω–µ—Ç", allCandles.size());

        List.of("USDC-USDT-SWAP").forEach(allCandles::remove);
        log.info("–£–¥–∞–ª–∏–ª–∏ —Ü–µ–Ω—ã —Ç–∏–∫–µ—Ä–æ–≤ –∏–∑ —á–µ—Ä–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞");

        fileService.writeAllCandlesToJson(allCandles);
        log.info("–°–æ—Ö—Ä–∞–Ω–∏–ª–∏ —Ü–µ–Ω—ã –≤ all_candles.json");

        log.info("üêç–ó–∞–ø—É—Å–∫–∞–µ–º —Å–∫—Ä–∏–ø—Ç—ã...");

        PythonScriptsExecuter.execute(PythonScripts.Z_SCORE_CANDLES.getName(), true);
        log.info("–ò—Å–ø–æ–ª–Ω–∏–ª–∏ —Å–∫—Ä–∏–ø—Ç " + PythonScripts.Z_SCORE_CANDLES.getName());

        fileService.keepPairWithMaxZScore();
        log.info("üîç –°–æ—Ö—Ä–∞–Ω–∏–ª–∏ –ª—É—á—à—É—é –ø–∞—Ä—É –≤ z_score.json");

        fileService.clearChartDir();
        log.info("–û—á–∏—Å—Ç–∏–ª–∏ –ø–∞–ø–∫—É —Å —á–∞—Ä—Ç–∞–º–∏");

        ZScoreEntry topPair = fileService.getTopPairEntry();

        EntryData entryData = createEntryData(topPair);
        log.info("–°–æ–∑–¥–∞–ª–∏ entry_data.json");

        PythonScriptsExecuter.execute(PythonScripts.CREATE_CHARTS_CANDLES.getName(), true);
        log.info("–ò—Å–ø–æ–ª–Ω–∏–ª–∏ —Å–∫—Ä–∏–ø—Ç " + PythonScripts.CREATE_CHARTS.getName());

        log.info("üêç—Å–∫—Ä–∏–ø—Ç—ã –æ—Ç—Ä–∞–±–æ—Ç–∞–ª–∏");

        updateCurrentPricesFromCandles(entryData, allCandles);
        log.info("–û–±–æ–≥–∞—Ç–∏–ª–∏ entry_data.json —Ü–µ–Ω–∞–º–∏ –∏–∑ all_candles.json");

        //–û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≥—Ä–∞—Ñ–∏–∫
        try {
            sendChart(chatId, fileService.getChart(), "üìäLONG " + topPair.getLongticker() + ", SHORT " + topPair.getShortticker(), true);
        } catch (Exception e) {
            log.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —á–∞—Ä—Ç–∞: {}", e.getMessage(), e);
        }

        long durationMillis = System.currentTimeMillis() - startTime;
        long minutes = durationMillis / 1000 / 60;
        long seconds = (durationMillis / 1000) % 60;
        log.info("–°–∫–∞–Ω –∑–∞–≤–µ—Ä—à–µ–Ω. –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ {} —Ç–∏–∫–µ—Ä–æ–≤ –∑–∞ {} –º–∏–Ω {} —Å–µ–∫", totalSymbols, minutes, seconds);
    }

    private void getCloses(Set<String> swapTickers, Settings settings) {
        ExecutorService executor = Executors.newFixedThreadPool(5);
        ConcurrentHashMap<String, List<Double>> allCloses = new ConcurrentHashMap<>();
        try {
            List<CompletableFuture<Void>> futures = swapTickers.stream()
                    .map(symbol -> CompletableFuture.runAsync(() -> {
                        try {
                            List<Double> closes = okxClient.getCloses(symbol, settings.getTimeframe(), settings.getCandleLimit());
                            allCloses.put(symbol, closes);
                        } catch (Exception e) {
                            log.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ {}: {}", symbol, e.getMessage(), e);
                        }
                    }, executor))
                    .toList();

            // –û–∂–∏–¥–∞–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö –∑–∞–¥–∞—á
            CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
        } finally {
            executor.shutdown();
        }
    }

    @NotNull
    private ConcurrentHashMap<String, List<Candle>> getCandlesMap(Set<String> swapTickers, Settings settings) {
        ExecutorService executor = Executors.newFixedThreadPool(5);
        ConcurrentHashMap<String, List<Candle>> allCandles = new ConcurrentHashMap<>();
        try {
            List<CompletableFuture<Void>> futures = swapTickers.stream()
                    .map(symbol -> CompletableFuture.runAsync(() -> {
                        try {
                            List<Candle> candles = okxClient.getCandleList(symbol, settings.getTimeframe(), settings.getCandleLimit());
                            allCandles.put(symbol, candles);
                        } catch (Exception e) {
                            log.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ {}: {}", symbol, e.getMessage(), e);
                        }
                    }, executor))
                    .toList();

            // –û–∂–∏–¥–∞–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö –∑–∞–¥–∞—á
            CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
        } finally {
            executor.shutdown();
        }
        return allCandles;
    }

    private void setupEntryPointsIfNeeded(EntryData entryData, ZScoreEntry topPair, ConcurrentHashMap<String, List<Double>> topPairCloses) {
        if (entryData.getLongTickerEntryPrice() == 0.0 || entryData.getShortTickerEntryPrice() == 0.0) {
            entryData.setLongticker(topPair.getLongticker());
            entryData.setShortticker(topPair.getShortticker());

            List<Double> longTickerCloses = topPairCloses.get(topPair.getLongticker());
            List<Double> shortTickerCloses = topPairCloses.get(topPair.getShortticker());

            entryData.setLongTickerEntryPrice(longTickerCloses.get(longTickerCloses.size() - 1));
            entryData.setShortTickerEntryPrice(shortTickerCloses.get(shortTickerCloses.size() - 1));
            entryData.setMeanEntry(topPair.getMean());
            entryData.setSpreadEntry(topPair.getSpread());
            fileService.writeEntryDataToJson(Collections.singletonList(entryData));
            log.info("üîπ–£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã —Ç–æ—á–∫–∏ –≤—Ö–æ–¥–∞: LONG {{}} = {}, SHORT {{}} = {}, SPREAD = {}, MEAN = {}", entryData.getLongticker(), entryData.getLongTickerEntryPrice(), entryData.getShortticker(), entryData.getShortTickerEntryPrice(), entryData.getSpreadEntry(), entryData.getMeanEntry());
        }
    }

    private void setupEntryPointsIfNeededFromCandles(EntryData entryData, ZScoreEntry topPair, ConcurrentHashMap<String, List<Candle>> topPairCandles) {
        if (entryData.getLongTickerEntryPrice() == 0.0 || entryData.getShortTickerEntryPrice() == 0.0) {
            entryData.setLongticker(topPair.getLongticker());
            entryData.setShortticker(topPair.getShortticker());

            List<Candle> longTickerCandles = topPairCandles.get(topPair.getLongticker());
            List<Candle> shortTickerCandles = topPairCandles.get(topPair.getShortticker());

            if (longTickerCandles == null || longTickerCandles.isEmpty() ||
                    shortTickerCandles == null || shortTickerCandles.isEmpty()) {
                log.warn("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –ø–æ —Å–≤–µ—á–∞–º –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Ç–æ—á–µ–∫ –≤—Ö–æ–¥–∞: {} - {}", topPair.getLongticker(), topPair.getShortticker());
                return;
            }

            Candle longCandle = longTickerCandles.get(longTickerCandles.size() - 1);
            Candle shortCandle = shortTickerCandles.get(shortTickerCandles.size() - 1);

            double longEntryPrice = longCandle.getClose();
            double shortEntryPrice = shortCandle.getClose();

            entryData.setLongTickerEntryPrice(longEntryPrice);
            entryData.setShortTickerEntryPrice(shortEntryPrice);
            entryData.setMeanEntry(topPair.getMean());
            entryData.setSpreadEntry(topPair.getSpread());

            // –°—Ç–∞–≤–∏–º –≤—Ä–µ–º—è –æ—Ç–∫—Ä—ã—Ç–∏—è –ø–æ long-—Å–≤–µ—á–∫–µ (–º–æ–∂–Ω–æ –∏ —É—Å—Ä–µ–¥–Ω–∏—Ç—å, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ)
            entryData.setEntryTime(longCandle.getTimestamp());

            fileService.writeEntryDataToJson(Collections.singletonList(entryData));

            log.info("üîπ–£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã —Ç–æ—á–∫–∏ –≤—Ö–æ–¥–∞: LONG {{}} = {}, SHORT {{}} = {}, SPREAD = {}, MEAN = {}, –í–†–ï–ú–Ø = {}",
                    entryData.getLongticker(), longEntryPrice,
                    entryData.getShortticker(), shortEntryPrice,
                    entryData.getSpreadEntry(), entryData.getMeanEntry(),
                    entryData.getEntryTime());
        }
    }


    private ConcurrentHashMap<String, List<Double>> getTopPairCloses(ZScoreEntry topPair, Settings settings) {
        List<Double> longTickerCloses = okxClient.getCloses(topPair.getLongticker(), settings.getTimeframe(), settings.getCandleLimit());
        List<Double> shortTickerCloses = okxClient.getCloses(topPair.getShortticker(), settings.getTimeframe(), settings.getCandleLimit());
        if (longTickerCloses.isEmpty() || shortTickerCloses.isEmpty()) {
            log.warn("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ü–µ–Ω—ã –¥–ª—è –ø–∞—Ä—ã: {} –∏ {}", topPair.getLongticker(), topPair.getShortticker());
            return null;
        }
        ConcurrentHashMap<String, List<Double>> topPairCloses = new ConcurrentHashMap<>();
        topPairCloses.put(topPair.getLongticker(), longTickerCloses);
        topPairCloses.put(topPair.getShortticker(), shortTickerCloses);
        fileService.writeAllClosesToJson(topPairCloses);
        return topPairCloses;
    }

    private ConcurrentHashMap<String, List<Candle>> saveCandlesToJson(ZScoreEntry topPair, Settings settings) {
        List<Candle> longTickerCandles = okxClient.getCandleList(
                topPair.getLongticker(),
                settings.getTimeframe(),
                settings.getCandleLimit()
        )
//                .stream()
//                .skip(Math.max(0, settings.getCandleLimit() - 2))
//                .collect(Collectors.toList())
                ;

        List<Candle> shortTickerCandles = okxClient.getCandleList(
                topPair.getShortticker(),
                settings.getTimeframe(),
                settings.getCandleLimit()
        )
//                .stream()
//                .skip(Math.max(0, settings.getCandleLimit() - 2))
//                .collect(Collectors.toList())
                ;

        ConcurrentHashMap<String, List<Candle>> allCandles = new ConcurrentHashMap<>();
        allCandles.put(topPair.getLongticker(), longTickerCandles);
        allCandles.put(topPair.getShortticker(), shortTickerCandles);

        fileService.writeAllCandlesToJson(allCandles); // —ç—Ç–æ—Ç –º–µ—Ç–æ–¥ –¥–æ–ª–∂–µ–Ω –ø—Ä–∏–Ω–∏–º–∞—Ç—å Map<String, List<Candle>>
        return allCandles;
    }


    public EntryData createEntryData(ZScoreEntry topPair) {
        EntryData entryData = new EntryData();
        entryData.setLongticker(topPair.getLongticker());
        entryData.setShortticker(topPair.getShortticker());
        fileService.writeEntryDataToJson(Collections.singletonList(entryData));
        return entryData;
    }

    private void updateCurrentPrices(EntryData entryData, ConcurrentHashMap<String, List<Double>> allCloses) {
        try {
            String longTicker = entryData.getLongticker();
            String shortTicker = entryData.getShortticker();

            List<Double> longTickerCloses = allCloses.get(longTicker);
            List<Double> shortTickerCloses = allCloses.get(shortTicker);

            if (longTickerCloses == null || longTickerCloses.isEmpty() || shortTickerCloses == null || shortTickerCloses.isEmpty()) {
                log.warn("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –ø–æ —Ü–µ–Ω–∞–º –¥–ª—è –ø–∞—Ä—ã: {} - {}", longTicker, shortTicker);
            }

            entryData.setLongTickerCurrentPrice(longTickerCloses.get(longTickerCloses.size() - 1));
            entryData.setShortTickerCurrentPrice(shortTickerCloses.get(shortTickerCloses.size() - 1));

            fileService.writeEntryDataToJson(Collections.singletonList(entryData));
        } catch (Exception e) {
            log.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–æ–≥–∞—â–µ–Ω–∏–∏ z_score.json –∏–∑ all_closes.json: {}", e.getMessage(), e);
        }
    }

    private void updateCurrentPricesFromCandles(EntryData entryData, ConcurrentHashMap<String, List<Candle>> allCandles) {
        try {
            String longTicker = entryData.getLongticker();
            String shortTicker = entryData.getShortticker();

            List<Candle> longTickerCandles = allCandles.get(longTicker);
            List<Candle> shortTickerCandles = allCandles.get(shortTicker);

            if (longTickerCandles == null || longTickerCandles.isEmpty() ||
                    shortTickerCandles == null || shortTickerCandles.isEmpty()) {
                log.warn("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –ø–æ —Å–≤–µ—á–∞–º –¥–ª—è –ø–∞—Ä—ã: {} - {}", longTicker, shortTicker);
                return;
            }

            double longPrice = longTickerCandles.get(longTickerCandles.size() - 1).getClose();
            double shortPrice = shortTickerCandles.get(shortTickerCandles.size() - 1).getClose();

            entryData.setLongTickerCurrentPrice(longPrice);
            entryData.setShortTickerCurrentPrice(shortPrice);

            fileService.writeEntryDataToJson(Collections.singletonList(entryData));
        } catch (Exception e) {
            log.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–æ–≥–∞—â–µ–Ω–∏–∏ z_score.json –∏–∑ —Å–≤–µ—á–µ–π: {}", e.getMessage(), e);
        }
    }

    private void sendChart(String chatId, File chartFile, String caption, boolean withLogging) {
        try {
            eventSendService.sendAsPhoto(SendAsPhotoEvent.builder()
                    .chatId(chatId)
                    .photo(chartFile)
                    .caption(caption)
                    .build());
            if (withLogging) {
                log.info("üì§ –ß–∞—Ä—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ Telegram: {}", chartFile.getName());
            }
        } catch (Exception e) {
            log.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —á–∞—Ä—Ç–∞: {}", e.getMessage(), e);
        }
    }

    private void sendSignal(String chatId, String text) {
        System.out.println(text);
        sendText(chatId, text);
    }

    private void sendText(String chatId, String text) {
        eventSendService.sendAsText(SendAsTextEvent.builder()
                .chatId(chatId)
                .text(text)
                .enableMarkdown(true)
                .build());
    }
}
